✅ PROGRAM 1 Read data from standard input and write to screen (read/write system calls)


#include <unistd.h>

int main() {
    int nread;
    char buff[20];

    nread = read(0, buff, 10);   // read from keyboard
    write(1, buff, nread);      // write to screen

    return 0;
}


✅ PROGRAM 2
Print 10 characters starting from 10th character using lseek()


#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    int fd;
    char buff[10];

    fd = open("seeking", O_RDWR);
    lseek(fd, 10, SEEK_SET);
    read(fd, buff, 10);
    write(1, buff, 10);

    return 0;
}




✅ PROGRAM 3
IPC using Shared Memory


Writer Process

#include <stdio.h>
#include <sys/shm.h>
#include <string.h>
#include <unistd.h>

int main() {
    void *shared_memory;
    char buff[100];
    int shmid;

    shmid = shmget((key_t)2345, 1024, 0666 | IPC_CREAT);
    shared_memory = shmat(shmid, NULL, 0);

    read(0, buff, 100);
    strcpy(shared_memory, buff);

    printf("You wrote: %s\n", (char *)shared_memory);
    return 0;
}


Reader Process


#include <stdio.h>
#include <sys/shm.h>

int main() {
    void *shared_memory;
    int shmid;

    shmid = shmget((key_t)2345, 1024, 0666);
    shared_memory = shmat(shmid, NULL, 0);

    printf("Data read: %s\n", (char *)shared_memory);
    return 0;
}



✅ PROGRAM 4
Producer–Consumer Problem (Semaphore logic)



#include <stdio.h>

int main() {
    int buffer[10], in = 0, out = 0, bufsize = 10;
    int produce, consume, choice = 0;

    while (choice != 3) {
        printf("\n1. Produce 2. Consume 3. Exit: ");
        scanf("%d", &choice);

        switch (choice) {
        case 1:
            if ((in + 1) % bufsize == out)
                printf("Buffer Full");
            else {
                scanf("%d", &produce);
                buffer[in] = produce;
                in = (in + 1) % bufsize;
            }
            break;

        case 2:
            if (in == out)
                printf("Buffer Empty");
            else {
                consume = buffer[out];
                printf("Consumed: %d", consume);
                out = (out + 1) % bufsize;
            }
            break;
        }
    }
    return 0;
}




✅ PROGRAM 5: Dining Philosopher’s Problem

#include <stdio.h>
#include <stdlib.h>

int one(void);
int two(void);

int tph, philname[20], status[20], howhung, hu[20], cho;

int main()
{
    int i;

    printf("\n\nDINING PHILOSOPHER PROBLEM");
    printf("\nEnter the total no. of philosophers: ");
    scanf("%d", &tph);

    for (i = 0; i < tph; i++)
    {
        philname[i] = i + 1;
        status[i] = 1;
    }

    printf("How many are hungry: ");
    scanf("%d", &howhung);

    if (howhung == tph)
    {
        printf("\nAll are hungry..\nDead lock stage will occur");
        printf("\nExiting..\n");
        exit(0);
    }
    else
    {
        for (i = 0; i < howhung; i++)
        {
            printf("Enter philosopher %d position: ", (i + 1));
            scanf("%d", &hu[i]);
            status[hu[i]] = 2;
        }

        do
        {
            printf("\n1.One can eat at a time");
            printf("\n2.Two can eat at a time");
            printf("\n3.Exit");
            printf("\nEnter your choice: ");
            scanf("%d", &cho);

            switch (cho)
            {
            case 1:
                one();
                break;

            case 2:
                two();
                break;

            case 3:
                exit(0);

            default:
                printf("\nInvalid option");
            }
        } while (1);
    }
    return 0;
}

int one()
{
    int pos = 0, x, i;

    printf("\nAllow one philosopher to eat at any time");

    for (i = 0; i < howhung; i++, pos++)
    {
        printf("\nP %d is granted to eat", philname[hu[pos]]);
        for (x = pos + 1; x < howhung; x++)
        {
            printf("\nP %d is waiting", philname[hu[x]]);
        }
    }
    return 0;
}

int two()
{
    int i, j, s = 0, t, r, x;

    printf("\nAllow two philosophers to eat at same time");

    for (i = 0; i < howhung; i++)
    {
        for (j = i + 1; j < howhung; j++)
        {
            if (abs(hu[i] - hu[j]) >= 1 && abs(hu[i] - hu[j]) != 4)
            {
                printf("\n\nCombination %d", ++s);

                t = hu[i];
                r = hu[j];

                printf("\nP %d and P %d are granted to eat",
                       philname[hu[i]], philname[hu[j]]);

                for (x = 0; x < howhung; x++)
                {
                    if (hu[x] != t && hu[x] != r)
                        printf("\nP %d is waiting", philname[hu[x]]);
                }
            }
        }
    }
    return 0;
}




✅ PROGRAM 6: Implement the FCFS CPU Scheduling Algorithm
#include <stdio.h>
#include <conio.h>

void main()
{
    int bt[20], wt[20], tat[20], i, n;
    float wtavg, tatavg;

    clrscr();

    printf("\nEnter the number of processes -- ");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        printf("\nEnter Burst Time for Process %d -- ", i);
        scanf("%d", &bt[i]);
    }

    wt[0] = wtavg = 0;
    tat[0] = tatavg = bt[0];

    for (i = 1; i < n; i++)
    {
        wt[i] = wt[i - 1] + bt[i - 1];
        tat[i] = tat[i - 1] + bt[i];
        wtavg = wtavg + wt[i];
        tatavg = tatavg + tat[i];
    }

    printf("\n\tPROCESS\tBURST TIME\tWAITING TIME\tTURNAROUND TIME\n");

    for (i = 0; i < n; i++)
        printf("\n\tP%d\t\t%d\t\t%d\t\t%d",
               i, bt[i], wt[i], tat[i]);

    printf("\n\nAverage Waiting Time -- %f", wtavg / n);
    printf("\nAverage Turnaround Time -- %f", tatavg / n);

    getch();
}





✅ PROGRAM 7: Banker’s Algorithm for Deadlock Avoidance
#include <stdio.h>
#include <conio.h>

int max[100][100];
int alloc[100][100];
int need[100][100];
int avail[100];
int n, r;

void input();
void show();
void cal();

int main()
{
    int i, j;

    printf("********** Banker's Algorithm ************\n");
    input();
    show();
    cal();
    getch();
    return 0;
}

void input()
{
    int i, j;

    printf("Enter the no of Processes\t");
    scanf("%d", &n);

    printf("Enter the no of resources instances\t");
    scanf("%d", &r);

    printf("Enter the Max Matrix\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < r; j++)
        {
            scanf("%d", &max[i][j]);
        }
    }

    printf("Enter the Allocation Matrix\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < r; j++)
        {
            scanf("%d", &alloc[i][j]);
        }
    }

    printf("Enter the available Resources\n");
    for (j = 0; j < r; j++)
    {
        scanf("%d", &avail[j]);
    }
}

void show()
{
    int i, j;

    printf("\nProcess\t Allocation\t Max\t Available\n");
    for (i = 0; i < n; i++)
    {
        printf("P%d\t ", i + 1);

        for (j = 0; j < r; j++)
            printf("%d ", alloc[i][j]);

        printf("\t\t");

        for (j = 0; j < r; j++)
            printf("%d ", max[i][j]);

        printf("\t\t");

        if (i == 0)
        {
            for (j = 0; j < r; j++)
                printf("%d ", avail[j]);
        }
        printf("\n");
    }
}

void cal()
{
    int finish[100], flag = 1, k, c1 = 0;
    int safe[100];
    int i, j;

    for (i = 0; i < n; i++)
        finish[i] = 0;

    // Calculate Need Matrix
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < r; j++)
        {
            need[i][j] = max[i][j] - alloc[i][j];
        }
    }

    printf("\n----Need Matrix-------\n");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < r; j++)
            printf("%d ", need[i][j]);
        printf("\n");
    }

    printf("\n");

    while (flag)
    {
        flag = 0;

        for (i = 0; i < n; i++)
        {
            int c = 0;

            for (j = 0; j < r; j++)
            {
                if ((finish[i] == 0) && (need[i][j] <= avail[j]))
                {
                    c++;
                    if (c == r)
                    {
                        for (k = 0; k < r; k++)
                            avail[k] += alloc[i][k];

                        finish[i] = 1;
                        flag = 1;
                        printf("P%d->", i + 1);
                    }
                }
            }
        }
    }

    printf("\n\n");

    for (i = 0; i < n; i++)
    {
        if (finish[i] == 1)
            c1++;
        else
            printf("P%d->", i + 1);
    }

    if (c1 == n)
        printf("\nThe system is in safe state");
    else
    {
        printf("\nProcess are in dead lock");
        printf("\nSystem is in unsafe state");
    }
}




✅ PROGRAM 8
Memory Allocation
a) First Fit
b) Worst Fit


FIRST FIT

#include <stdio.h>

#define MAX 25

int main() {
int frag[MAX], b[MAX], f[MAX];
int bf[MAX] = {0}, ff[MAX] = {0};
int i, j, nb, nf, temp;

printf("\nMemory Management Scheme - First Fit\n");

printf("\nEnter the number of blocks: ");
scanf("%d", &nb);

if (nb > MAX) return 1;

printf("Enter the number of files: ");
scanf("%d", &nf);

if (nf > MAX) return 1;

printf("\nEnter the size of the blocks:\n");
for (i = 0; i < nb; i++) {
    printf("Block %d: ", i + 1);
    scanf("%d", &b[i]);
}

printf("\nEnter the size of the files:\n");
for (i = 0; i < nf; i++) {
    printf("File %d: ", i + 1);
    scanf("%d", &f[i]);
}

for (i = 0; i < nf; i++) {
    ff[i] = -1;
    temp = -1;
    for (j = 0; j < nb; j++) {
        if (bf[j] == 0 && b[j] >= f[i]) {
            ff[i] = j;
            bf[j] = 1;
            temp = b[j] - f[i];
            break;
        }
    }
    frag[i] = temp;
}

printf("\nFile_no\tFile_size\tBlock_no\tBlock_size\tFragment");
for (i = 0; i < nf; i++) {
    if (ff[i] != -1)
        printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d", i + 1, f[i], ff[i] + 1, b[ff[i]], frag[i]);
    else
        printf("\n%d\t\t%d\t\t-\t\t-\t\t-", i + 1, f[i]);
}

printf("\n");
return 0;
}




WORST FIT

#include <stdio.h>

#define MAX 25

int main()
{
int frag[MAX], b[MAX], f[MAX];
int bf[MAX] = {0}, ff[MAX] = {0};
int i, j, nb, nf, temp, highest;

printf("\nMemory Management Scheme - Worst Fit\n");

printf("Enter the number of blocks: ");
scanf("%d", &nb);

printf("Enter the number of files: ");
scanf("%d", &nf);

printf("\nEnter the size of the blocks:\n");
for (i = 0; i < nb; i++)
{
    printf("Block %d: ", i + 1);
    scanf("%d", &b[i]);
}

printf("\nEnter the size of the files:\n");
for (i = 0; i < nf; i++)
{
    printf("File %d: ", i + 1);
    scanf("%d", &f[i]);
}

for (i = 0; i < nf; i++)
{
    highest = -1;
    ff[i] = -1;

    for (j = 0; j < nb; j++)
    {
        if (bf[j] == 0 && b[j] >= f[i])
        {
            temp = b[j] - f[i];
            if (temp > highest)
            {
                highest = temp;
                ff[i] = j;
            }
        }
    }

    frag[i] = highest;
    if (ff[i] != -1)
        bf[ff[i]] = 1;
}

printf("\nFile_no\tFile_size\tBlock_no\tBlock_size\tFragment");
for (i = 0; i < nf; i++)
{
    if (ff[i] != -1)
        printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d", i + 1, f[i], ff[i] + 1, b[ff[i]], frag[i]);
    else
        printf("\n%d\t\t%d\t\t-\t\t-\t\t-", i + 1, f[i]);
}

printf("\n");
return 0;
}



✅ PROGRAM 9
Page Replacement
a) FIFO
b) LRU


FIFO

#include <stdio.h>
#include <stdlib.h>
main()
{
int i, j, k, f, pf = 0, count = 0, rs[25], m[10], n;

printf("\n Enter the length of reference string -- ");
scanf("%d", &n);
printf("\n Enter the reference string -- ");
for (i = 0; i < n; i++)
    scanf("%d", &rs[i]);
printf("\n Enter no. of frames -- ");
scanf("%d", &f);
for (i = 0; i < f; i++)
    m[i] = -1;
printf("\n The Page Replacement Process is -- \n");
for (i = 0; i < n; i++)
{
    for (k = 0; k < f; k++)
    {
        if (m[k] == rs[i])
            break;
    }
    if (k == f)
    {
        m[count++] = rs[i];
        pf++;
    }
    for (j = 0; j < f; j++)
        printf("\t%d", m[j]);
    if (k == f)
        printf("\tPF No. %d", pf);
    printf("\n");
    if (count == f)
        count = 0;
}
printf("\n The number of Page Faults using FIFO are %d", pf);
}




LRU

#include <stdio.h>

int main(void)
{
int i, j, min;
int rs[25], m[10], count[10], flag[25];
int n, f, pf = 0, next = 1, filled = 0;

printf("Enter the length of reference string -- ");
scanf("%d", &n);

printf("Enter the reference string -- ");
for (i = 0; i < n; i++)
{
    scanf("%d", &rs[i]);
    flag[i] = 0;
}

printf("Enter the number of frames -- ");
scanf("%d", &f);

for (i = 0; i < f; i++)
{
    count[i] = 0;
    m[i] = -1;
}

printf("\nThe Page Replacement process is -- \n");

for (i = 0; i < n; i++)
{
    for (j = 0; j < f; j++)
    {
        if (m[j] == rs[i])
        {
            flag[i] = 1;
            count[j] = next++;
            break;
        }
    }

    if (flag[i] == 0)
    {
        if (filled < f)
        {
            m[filled] = rs[i];
            count[filled] = next++;
            filled++;
        }
        else
        {
            min = 0;
            for (j = 1; j < f; j++)
                if (count[j] < count[min])
                    min = j;

            m[min] = rs[i];
            count[min] = next++;
        }
        pf++;
    }

    for (j = 0; j < f; j++)
    {
        if (m[j] == -1)
            printf("-\t");
        else
            printf("%d\t", m[j]);
    }

    if (flag[i] == 0)
        printf("PF No. -- %d", pf);
    else
        printf("Hit");

    printf("\n");
}

printf("\nThe number of page faults using LRU are %d\n", pf);
return 0;
}


✅ PROGRAM 10
Disk Scheduling
a) SSTF
b) SCAN


STTF

#include <stdio.h>

#include <math.h>
int main()
{
int queue[100], t[100], head, seek = 0, n, i, j, temp;
float avg;
printf("*** SSTF Disk Scheduling Algorithm ***\n");
printf("Enter the size of Queue\t");
scanf("%d", &n);
printf("Enter the Queue\t");
for (i = 0; i < n; i++)
{
scanf("%d", &queue[i]);
}
printf("Enter the initial head position\t");
scanf("%d", &head);
for (i = 1; i < n; i++)
t[i] = abs(head - queue[i]);
for (i = 0; i < n; i++)
{
for (j = i + 1; j < n; j++)
{
if (t[i] > t[j])
{
temp = t[i];
t[i] = t[j];
t[j] = temp;
temp = queue[i];
queue[i] = queue[j];
queue[j] = temp;
}
}
}
for (i = 1; i < n - 1; i++)
{
seek = seek + abs(head - queue[i]);
head = queue[i];
}
printf("\nTotal Seek Time is%d\t", seek);
avg = seek / (float)n;
printf("\nAverage Seek Time is %f\t", avg);
return 0;
}





SCAN

#include <stdio.h>
void main()
{
int t[20], d[20], h, i, j, n, temp, k, atr[20], tot, p, sum = 0;

printf("enter the no of tracks to be traveresed");
scanf("%d'", &n);
printf("enter the position of head");
scanf("%d", &h);
t[0] = 0;
t[1] = h;
printf("enter the tracks");
for (i = 2; i < n + 2; i++)
    scanf("%d", &t[i]);
for (i = 0; i < n + 2; i++)
{
    for (j = 0; j < (n + 2) - i - 1; j++)
    {
        if (t[j] > t[j + 1])
        {
            temp = t[j];
            t[j] = t[j + 1];
            t[j + 1] = temp;
        }
    }
}
for (i = 0; i < n + 2; i++)
    if (t[i] == h)
        j = i;
k = j;
p = 0;
while (t[j] != 0)
{
    atr[p] = t[j];
    j--;
    p++;
}
atr[p] = t[j];
for (p = k + 1; p < n + 2; p++, k++)
    atr[p] = t[k + 1];
for (j = 0; j < n + 1; j++)
{
    if (atr[j] > atr[j + 1])
        d[j] = atr[j] - atr[j + 1];
    else
        d[j] = atr[j + 1] - atr[j];
    sum += d[j];
}
printf("\nAverage header movements:%f", (float)sum / n);
}



✅ PROGRAM 11
File Allocation
a) Sequential
b) Indexed

SEQUENTIAL

#include <stdio.h>
struct fileTable
{
char name[20];
int sb, nob;
} ft[30];

void main()
{
int i, j, n;
char s[20];
printf("Enter no of files :");
scanf("%d", &n);
for (i = 0; i < n; i++)
{
printf("\nEnter file name %d :", i + 1);
scanf("%s", ft[i].name);
printf("Enter starting block of file %d :", i + 1);
scanf("%d", &ft[i].sb);
printf("Enter no of blocks in file %d :", i + 1);
scanf("%d", &ft[i].nob);
}
printf("\nEnter the file name to be searched -- ");
scanf("%s", s);
for (i = 0; i < n; i++)
if (strcmp(s, ft[i].name) == 0)
break;
if (i == n)
printf("\nFile Not Found");
else
{
printf("\nFILE NAME START BLOCK NO OF BLOCKS BLOCKS OCCUPIED\n");
printf("\n%s\t\t%d\t\t%d\t", ft[i].name, ft[i].sb, ft[i].nob);
for (j = 0; j < ft[i].nob; j++)
printf("%d, ", ft[i].sb + j);
}
}




INDEXED

#include <stdio.h>
struct fileTable
{
char name[20];
int nob, blocks[30];
} ft[30];
void main()
{
int i, j, n;
char s[20];
clrscr();
printf("Enter no of files :");
scanf("%d", &n);
for (i = 0; i < n; i++)
{
printf("\nEnter file name %d :", i + 1);
scanf("%s", ft[i].name);
printf("Enter no of blocks in file %d :", i + 1);
scanf("%d", &ft[i].nob);
printf("Enter the blocks of the file :");
for (j = 0; j < ft[i].nob; j++)
scanf("%d", &ft[i].blocks[j]);
}
printf("\nEnter the file name to be searched -- ");
scanf("%s", s);
for (i = 0; i < n; i++)
if (strcmp(s, ft[i].name) == 0)
break;
if (i == n)
printf("\nFile Not Found");
else
{
printf("\nFILE NAME NO OF BLOCKS BLOCKS OCCUPIED");
printf("\n %s\t\t%d\t", ft[i].name, ft[i].nob);
for (j = 0; j < ft[i].nob; j++)
printf("%d, ", ft[i].blocks[j]);
}
}
